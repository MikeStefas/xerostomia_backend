import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';
import { PrismaService } from '../prisma/prisma.service'; // Adjust path if needed
import { reportDto } from './report.dto';
import { UserDataDto } from './userdata.dto';

// Mock the PrismaService
const mockPrismaService = {
  report: {
    create: jest.fn(),
    findMany: jest.fn(),
  },
  userData: {
    create: jest.fn(),
  },
};

describe('UserService', () => {
  let service: UserService;
  let prisma: PrismaService; // Keep a reference to the mock Prisma service for assertions

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UserService,
        {
          provide: PrismaService, // Provide the mock for PrismaService
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<UserService>(UserService);
    prisma = module.get<PrismaService>(PrismaService); // Get the mock instance

    // Clear all mocks before each test to ensure isolation
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('uploadReport', () => {
    it('should successfully create a new report in the database', async () => {
      const mockUser = { userID: 1, email: 'user@example.com' };
      const mockReportDto: reportDto = {
        tongue: 'red',
        tonguePercentage: 70,
        teeth: 'white',
        teethPercentage: 90,
        saliva: 'normal',
        salivaPercentage: 80,
        pain: 'none',
        painPercentage: 0,
      };
      // Mock Prisma's create method to return a resolved value (or simply undefined if it doesn't return anything specific)
      mockPrismaService.report.create.mockResolvedValueOnce({
        id: 1, // Example ID generated by Prisma
        ...mockUser,
        ...mockReportDto,
      });

      await service.uploadReport(mockUser, mockReportDto);

      expect(mockPrismaService.report.create).toHaveBeenCalledWith({
        data: {
          userID: mockUser.userID,
          email: mockUser.email,
          tongue: mockReportDto.tongue,
          tonguePercentage: mockReportDto.tonguePercentage,
          teeth: mockReportDto.teeth,
          teethPercentage: mockReportDto.teethPercentage,
          saliva: mockReportDto.saliva,
          salivaPercentage: mockReportDto.salivaPercentage,
          pain: mockReportDto.pain,
          painPercentage: mockReportDto.painPercentage,
        },
      });
      // No explicit return from uploadReport, so we just check if the mock was called
    });

    it('should handle errors if report creation fails', async () => {
      const mockUser = { userID: 1, email: 'user@example.com' };
      const mockReportDto: reportDto = {
        tongue: 'red',
        tonguePercentage: 70,
        teeth: 'white',
        teethPercentage: 90,
        saliva: 'normal',
        salivaPercentage: 80,
        pain: 'none',
        painPercentage: 0,
      };
      const errorMessage = 'Database write error';
      mockPrismaService.report.create.mockRejectedValueOnce(new Error(errorMessage));

      await expect(service.uploadReport(mockUser, mockReportDto)).rejects.toThrow(errorMessage);
      expect(mockPrismaService.report.create).toHaveBeenCalled(); // Ensure it was attempted
    });
  });

  describe('uploadUserData', () => {
    it('should successfully create new user data in the database', async () => {
      const mockUser = { userID: 1, email: 'user@example.com' };
      const mockUserDataDto: UserDataDto = {
        yearOfBirth: 1990,
        gender: 'Male',
      };
      mockPrismaService.userData.create.mockResolvedValueOnce({
        id: 1, // Example ID
        ...mockUser,
        ...mockUserDataDto,
      });

      await service.uploadUserData(mockUser, mockUserDataDto);

      expect(mockPrismaService.userData.create).toHaveBeenCalledWith({
        data: {
          userID: mockUser.userID,
          yearOfBirth: mockUserDataDto.yearOfBirth,
          gender: mockUserDataDto.gender,
        },
      });
    });

    it('should handle errors if user data creation fails', async () => {
      const mockUser = { userID: 1, email: 'user@example.com' };
      const mockUserDataDto: UserDataDto = {
        yearOfBirth: 1990,
        gender: 'Male',
      };
      const errorMessage = 'Failed to save user data';
      mockPrismaService.userData.create.mockRejectedValueOnce(new Error(errorMessage));

      await expect(service.uploadUserData(mockUser, mockUserDataDto)).rejects.toThrow(errorMessage);
      expect(mockPrismaService.userData.create).toHaveBeenCalled();
    });
  });

  describe('getReports', () => {
    it('should return all reports for a specific user ID', async () => {
      const mockUser = { userID: 1, email: 'user@example.com' };
      const expectedReports = [
        { id: 1, userID: 1, tongue: 'red', pain: 'none' },
        { id: 2, userID: 1, tongue: 'pale', pain: 'mild' },
      ];
      mockPrismaService.report.findMany.mockResolvedValueOnce(expectedReports);

      const result = await service.getReports(mockUser);

      expect(mockPrismaService.report.findMany).toHaveBeenCalledWith({
        where: { userID: mockUser.userID },
      });
      expect(result).toEqual(expectedReports);
    });

    it('should return an empty array if no reports are found for the user', async () => {
      const mockUser = { userID: 2, email: 'another@example.com' };
      mockPrismaService.report.findMany.mockResolvedValueOnce([]);

      const result = await service.getReports(mockUser);

      expect(mockPrismaService.report.findMany).toHaveBeenCalledWith({
        where: { userID: mockUser.userID },
      });
      expect(result).toEqual([]);
    });

    it('should handle errors if fetching reports fails', async () => {
      const mockUser = { userID: 1, email: 'user@example.com' };
      const errorMessage = 'Database read error';
      mockPrismaService.report.findMany.mockRejectedValueOnce(new Error(errorMessage));

      await expect(service.getReports(mockUser)).rejects.toThrow(errorMessage);
      expect(mockPrismaService.report.findMany).toHaveBeenCalled();
    });
  });
});